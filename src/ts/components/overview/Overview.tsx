import React from "react";
import {
  OverviewTotals,
  OverviewSummary,
  OverviewHistory,
  OverviewProps,
  Hotspot
} from "@/types";

/* =========================================================================
   Overview (root)
   ========================================================================= */

export default function Overview({
  summary,
  totals,
  history,
  hotspots
}: OverviewProps) {
  const [sortHotspotsBy, setSortHotspotsBy] = React.useState<"score" | "file" | "reason">("score");
  return (
    <section className="space-y-4">
      <SummaryBar info={summary} totals={totals} />
      <KpiGrid totals={totals} history={history} />
      <HistoryCard history={history} />
      <HotspotsCard hotspots={hotspots} sortBy={sortHotspotsBy} onSortBy={setSortHotspotsBy} />
    </section>
  );
}

/* =========================================================================
   Small form atoms
   ========================================================================= */

function SelectField<T extends string>({
  label,
  value,
  onChange,
  options,
  className,
}: {
  label: string;
  value: T | string;
  onChange: (v: T | string) => void;
  options: { value: T | string; label: string }[];
  className?: string;
}) {
  return (
    <label className={`form-control ${className ?? ""}`}>
      <div className="label py-1">
        <span className="label-text text-xs">{label}</span>
      </div>
      <select
        className="select select-sm select-bordered"
        value={value}
        onChange={(e) => onChange(e.target.value as T)}
      >
        {options.map((o) => (
          <option key={String(o.value)} value={o.value}>
            {o.label}
          </option>
        ))}
      </select>
    </label>
  );
}

/* =========================================================================
   SummaryBar
   ========================================================================= */

function SummaryBar({ info, totals }: { info: OverviewSummary; totals: OverviewTotals }) {
  return (
    <div className="bg bg-base-200 card border">
      <div className="card-body py-3">
        <div className="flex flex-wrap items-center gap-x-6 gap-y-1 text-sm">
          <Badge label="Parser" value={info.parser} />
          <Badge label="Assemblies" value={info.assemblies} />
          <Badge label="Classes" value={info.classes} />
          <Badge label="Files" value={info.files} />
          <div className="ml-auto flex items-center gap-3 text-xs text-base-content/60">
            {info.generatedBy && <span>Generated by: {info.generatedBy}</span>}
            {info.generatedAt && <span>{formatDate(info.generatedAt)}</span>}
          </div>
        </div>
      </div>
    </div>
  );
}

function Badge({ label, value }: { label: string; value: React.ReactNode }) {
  return (
    <div className="inline-flex items-center gap-2">
      <span className="text-base-content/60">{label}:</span>
      <span className="rounded bg-base-200 px-2 py-0.5">{value ?? "—"}</span>
    </div>
  );
}

/* =========================================================================
   KPI Grid
   ========================================================================= */

function KpiGrid({ totals, history }: { totals: OverviewTotals; history?: OverviewHistory[] }) {
  return (
    <div className="grid gap-4 md:grid-cols-4">
      <KpiCard
        title="Line coverage"
        mainPct={totals.lines.pct}
        counts={[
          ["Covered lines", totals.lines.covered],
          ["Uncovered lines", totals.lines.uncovered],
          ["Coverable lines", totals.lines.coverable],
          ["Total lines", totals.lines.total],
        ]}
        deltaPct={deltaFromHistory(history?.map((h) => h.linePct))}
      />
      <KpiCard
        title="Branch coverage"
        mainPct={totals.branches.pct}
        counts={[
          ["Covered branches", totals.branches.covered],
          ["Total branches", totals.branches.total],
        ]}
        deltaPct={deltaFromHistory(history?.map((h) => h.branchPct))}
      />
      <KpiCard
        title="Method coverage"
        mainPct={totals.methods.pct}
        counts={[
          ["Covered methods", totals.methods.covered],
          ["Fully covered methods", totals.methods.fullCovered],
          ["Total methods", totals.methods.total],
        ]}
        deltaPct={deltaFromHistory(history?.map((h) => h.methodPct))}
      />
      <KpiCard
        title="Full method coverage"
        mainPct={totals.methods.fullPct}
        counts={[
          ["Full method coverage", totals.methods.fullPct != null ? fmtPct(totals.methods.fullPct) : "—"],
          ["Fully covered methods", totals.methods.fullCovered],
          ["Total methods", totals.methods.total],
        ]}
        deltaPct={deltaFromHistory(history?.map((h) => h.fullMethodPct))}
      />
    </div>
  );
}

function KpiCard({
  title,
  mainPct,
  counts,
  deltaPct,
}: {
  title: string;
  mainPct: number;
  counts: [string, number | string | undefined][];
  deltaPct?: number | null;
}) {
  const barClass = getBarClass(mainPct);
  return (
    <div className="bg bg-base-200 card border">
      <div className="card-body">
        <div className="flex items-start justify-between gap-2">
          <h3 className="card-title">{title}</h3>
          <DeltaBadge delta={deltaPct ?? undefined} />
        </div>
        <div className="mt-2 flex items-baseline gap-2">
          <div className="text-3xl font-semibold tabular-nums">{fmtPct(mainPct)}</div>
        </div>
        <div className="mt-3 h-2 w-full overflow-hidden rounded bg-base-200">
          <div className={`h-full ${barClass}`} style={{ width: `${clamp(mainPct, 0, 100)}%` }} />
        </div>
        <ul className="mt-3 space-y-1 text-sm">
          {counts.map(([k, v]) => (
            <li key={k} className="flex items-center justify-between gap-4">
              <span className="text-base-content/70">{k}</span>
              <span className="font-medium">{v ?? "—"}</span>
            </li>
          ))}
        </ul>
      </div>
    </div>
  );
}

function DeltaBadge({ delta }: { delta?: number | null }) {
  if (!Number.isFinite(delta as number) || (delta as number) === 0) return null;
  const d = delta as number;
  const up = d > 0;
  return (
    <span className={`badge gap-1 ${up ? "badge-success" : "badge-error"}`} title={up ? "Improved" : "Regressed"}>
      <svg width="12" height="12" viewBox="0 0 24 24" aria-hidden>
        {up ? <path fill="currentColor" d="M7 14l5-5 5 5H7z" /> : <path fill="currentColor" d="M7 10l5 5 5-5H7z" />}
      </svg>
      {Math.abs(d).toFixed(1)}%
    </span>
  );
}

/* =========================================================================
   History
   ========================================================================= */

function HistoryCard({ history }: { history?: OverviewHistory[] }) {
  if (!history?.length) {
    return (
      <div className="bg bg-base-200 card border">
        <div className="card-body py-4">
          <h3 className="card-title">Coverage history</h3>
          <p className="text-sm text-base-content/60">No history yet.</p>
        </div>
      </div>
    );
  }
  return (
    <div className="bg bg-base-200 card border">
      <div className="card-body">
        <h3 className="card-title">Coverage history</h3>
        <HistorySparklines history={history} />
      </div>
    </div>
  );
}

function HistorySparklines({ history }: { history: OverviewHistory[] }) {
  return (
    <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-4">
      <Sparkline title="Line %" data={history.map((h) => h.linePct)} />
      <Sparkline title="Branch %" data={history.map((h) => h.branchPct)} />
      <Sparkline title="Method %" data={history.map((h) => h.methodPct)} />
      <Sparkline title="Full method %" data={history.map((h) => h.fullMethodPct)} />
    </div>
  );
}

function Sparkline({ title, data }: { title: string; data: number[] }) {
  const w = 220,
    h = 48,
    pad = 6;
  const xs = data.map((_, i) => (i / Math.max(1, data.length - 1)) * (w - pad * 2) + pad);
  const ys = data.map((v) => (1 - clamp(v, 0, 100) / 100) * (h - pad * 2) + pad);
  const d = xs.map((x, i) => `${i === 0 ? "M" : "L"}${x.toFixed(1)},${ys[i].toFixed(1)}`).join(" ");
  const last = data[data.length - 1];
  return (
    <div>
      <div className="mb-1 flex items-baseline justify-between">
        <span className="font-medium">{title}</span>
        <span className="text-xs text-base-content/60">{fmtPct(last)}</span>
      </div>
      <svg width={w} height={h} viewBox={`0 0 ${w} ${h}`} className="block">
        <rect x="0" y="0" width={w} height={h} rx="6" className="fill-base-300" />
        <path d={d} fill="none" stroke="currentColor" strokeOpacity="0.7" strokeWidth="2" />
        <circle cx={xs[xs.length - 1]} cy={ys[ys.length - 1]} r="2.5" className="fill-primary" />
      </svg>
    </div>
  );
}

/* =========================================================================
   Hotspots
   ========================================================================= */

function HotspotsCard({
  hotspots,
  sortBy,
  onSortBy,
}: {
  hotspots?: Hotspot[];
  sortBy: "score" | "file" | "reason";
  onSortBy: (s: "score" | "file" | "reason") => void;
}) {
  const items = React.useMemo(() => {
    const arr = [...(hotspots ?? [])];
    arr.sort((a, b) => {
      if (sortBy === "score") return (b.score ?? 0) - (a.score ?? 0);
      if (sortBy === "file") return (a.file || "").localeCompare(b.file || "");
      return (a.reason || "").localeCompare(b.reason || "");
    });
    return arr;
  }, [hotspots, sortBy]);

  return (
    <div className="bg bg-base-200 card border">
      <div className="card-body">
        <div className="flex items-center justify-between gap-3">
          <h3 className="card-title">Risk Hotspots</h3>
          <SelectField
            label="Sort by"
            value={sortBy}
            onChange={(v) => onSortBy(v as any)}
            options={[
              { value: "score", label: "Risk score" },
              { value: "file", label: "File" },
              { value: "reason", label: "Reason" },
            ]}
            className="w-40"
          />
        </div>

        {!items.length ? (
          <p className="text-sm text-base-content/60">No risk hotspots found.</p>
        ) : (
          <div className="mt-2 grid gap-2 md:grid-cols-2">
            {items.map((h, idx) => (
              <HotspotRow key={`${h.file}:${h.lines ?? idx}`} hotspot={h} />
            ))}
          </div>
        )}
      </div>
    </div>
  );
}

function HotspotRow({ hotspot }: { hotspot: Hotspot }) {
  const color =
    hotspot.score >= 75 ? "badge-error" : hotspot.score >= 50 ? "badge-warning" : hotspot.score >= 25 ? "badge-info" : "badge-success";

  return (
    <div className="group rounded-lg border bg-base-100/60 p-3">
      <div className="flex items-start justify-between gap-3">
        <div className="min-w-0">
          <div className="flex items-center gap-2">
            <span className="truncate font-medium">{hotspot.file}</span>
            {hotspot.lines && (
              <code className="rounded bg-base-200 px-1.5 py-0.5 text-xs text-base-content/70">{hotspot.lines}</code>
            )}
          </div>
          {hotspot.function && <div className="mt-0.5 truncate text-xs text-base-content/70">{hotspot.function}</div>}
          <div className="mt-2 text-xs text-base-content/60 capitalize">Reason: {hotspot.reason.replace("-", " ")}</div>
        </div>
        <span className={`badge ${color} font-medium`}>{Math.round(hotspot.score)} / 100</span>
      </div>
      <div className="mt-2 h-1.5 w-full overflow-hidden rounded bg-base-200">
        <div className="h-full bg-error/70" style={{ width: `${clamp(hotspot.score, 0, 100)}%` }} />
      </div>
    </div>
  );
}

/* =========================================================================
   Utils
   ========================================================================= */

function clamp(n: number, min: number, max: number) {
  return Math.min(max, Math.max(min, n));
}

function fmtPct(n: number) {
  return Number.isFinite(n) ? `${clamp(n, 0, 100).toFixed(1)}%` : "—";
}

function getBarClass(pct: number) {
  if (!Number.isFinite(pct)) return "bg-base-300";
  if (pct >= 90) return "bg-success";
  if (pct >= 75) return "bg-info";
  if (pct >= 60) return "bg-warning";
  return "bg-error";
}

function deltaFromHistory(series?: number[]) {
  if (!series || series.length < 2) return null;
  const prev = series[series.length - 2];
  const last = series[series.length - 1];
  if (!Number.isFinite(prev) || !Number.isFinite(last)) return null;
  return +(last - prev).toFixed(1);
}

function formatDate(s: string) {
  const d = new Date(s);
  if (isNaN(+d)) return s;
  const pad = (n: number) => `${n}`.padStart(2, "0");
  return `${pad(d.getDate())}.${pad(d.getMonth() + 1)}.${d.getFullYear()} - ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
}
